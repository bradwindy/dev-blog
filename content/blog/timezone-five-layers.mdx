---
title: "The Timezone Problem: A 5-Layer Solution"
description: "How a simple calendar MCP server led to a comprehensive timezone handling architecture."
publishedAt: 2026-01-10
tags: ["Python", "datetime", "architecture"]
draft: false
---

Building an MCP server for calendar management seemed straightforward—until I hit timezones. What started as a simple bug fix became a complete architectural redesign.

## The Problem

EventKit (Apple's calendar framework) requires naive datetimes in local time. But MCP tools receive timezone-aware datetimes. And recurring events span timezone boundaries.

Initial symptoms:
- Events created at wrong times
- Recurring event updates failing
- Cross-timezone queries returning wrong results

## The Wrong Approach

My first fix: Convert everything to UTC.

```python
# DON'T DO THIS
def to_utc(dt: datetime) -> datetime:
    return dt.astimezone(timezone.utc)
```

This broke immediately. EventKit doesn't want UTC—it wants naive local time. Converting to UTC then stripping timezone info shifted events by hours.

## The 5-Layer Architecture

After much debugging, I developed a 5-layer approach:

### Layer 1: Model Layer (Always Aware)

All internal `Event` objects use timezone-aware datetimes:

```python
@dataclass
class Event:
    start: datetime  # Always timezone-aware
    end: datetime    # Always timezone-aware
    timezone: str    # Original timezone for display
```

### Layer 2: Input Boundary

Convert incoming datetimes to aware local time immediately:

```python
def normalize_input(dt: datetime | str) -> datetime:
    if isinstance(dt, str):
        dt = parser.parse(dt)

    if dt.tzinfo is None:
        # Assume local timezone for naive inputs
        return dt.replace(tzinfo=get_local_timezone())

    # Convert to local for consistent handling
    return dt.astimezone(get_local_timezone())
```

### Layer 3: EventKit Boundary

Convert to naive local time only at the EventKit API boundary:

```python
def to_eventkit_datetime(dt: datetime) -> datetime:
    """Convert to naive local time for EventKit."""
    if dt.tzinfo is not None:
        local_dt = dt.astimezone(get_local_timezone())
        return local_dt.replace(tzinfo=None)
    return dt
```

<Callout type="tip">
This is the key insight: Keep datetimes aware internally, convert to naive only at the OS API boundary.
</Callout>

### Layer 4: Query Normalization

For date range queries, normalize boundaries to local midnight:

```python
def normalize_query_range(start: datetime, end: datetime) -> tuple[datetime, datetime]:
    """Ensure query boundaries align with local calendar days."""
    local_start = start.astimezone(get_local_timezone())
    local_end = end.astimezone(get_local_timezone())

    # Align to start/end of day
    day_start = local_start.replace(hour=0, minute=0, second=0, microsecond=0)
    day_end = local_end.replace(hour=23, minute=59, second=59, microsecond=999999)

    return day_start, day_end
```

### Layer 5: Occurrence Matching

For recurring events, match specific occurrences across timezone changes:

```python
def find_event_occurrence(
    self,
    event_id: str,
    occurrence_date: datetime
) -> Event | None:
    """Find a specific occurrence of a recurring event."""
    event = self.get_event(event_id)
    if not event:
        return None

    # Normalize the target date to local timezone
    target_local = occurrence_date.astimezone(get_local_timezone())
    target_date = target_local.date()

    # Find occurrences on that date
    for occurrence in event.occurrences(target_date, target_date):
        if occurrence.start.date() == target_date:
            return occurrence

    return None
```

## The Result

After implementing all 5 layers:
- Events created at correct times regardless of input format
- Recurring events update correctly
- Cross-timezone queries return expected results
- Users in any timezone get consistent behavior

## Lessons Learned

1. **Naive datetimes are a code smell**—make everything aware internally
2. **Boundary conversion is key**—convert at the edges, not throughout
3. **Test across timezones**—set `TZ` environment variable in tests
4. **Document assumptions**—which layers expect which formats

<Callout type="warning">
If you're storing datetimes, store them with timezone info. Naive datetimes are only acceptable at API boundaries that require them.
</Callout>

## Full Implementation

See the complete timezone handling in [mcp-ical on GitHub](https://github.com/bradleywilson/mcp-ical).
